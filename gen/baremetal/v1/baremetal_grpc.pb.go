// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: proto/baremetal/v1/baremetal.proto

package baremetalv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MachineService_RegisterMachine_FullMethodName = "/baremetal.v1.MachineService/RegisterMachine"
	MachineService_GetMachine_FullMethodName      = "/baremetal.v1.MachineService/GetMachine"
	MachineService_ListMachines_FullMethodName    = "/baremetal.v1.MachineService/ListMachines"
	MachineService_UpdateMachine_FullMethodName   = "/baremetal.v1.MachineService/UpdateMachine"
)

// MachineServiceClient is the client API for MachineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MachineServiceClient interface {
	RegisterMachine(ctx context.Context, in *RegisterMachineRequest, opts ...grpc.CallOption) (*Machine, error)
	GetMachine(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*Machine, error)
	ListMachines(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListMachinesResponse, error)
	UpdateMachine(ctx context.Context, in *UpdateMachineRequest, opts ...grpc.CallOption) (*Machine, error)
}

type machineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMachineServiceClient(cc grpc.ClientConnInterface) MachineServiceClient {
	return &machineServiceClient{cc}
}

func (c *machineServiceClient) RegisterMachine(ctx context.Context, in *RegisterMachineRequest, opts ...grpc.CallOption) (*Machine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Machine)
	err := c.cc.Invoke(ctx, MachineService_RegisterMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) GetMachine(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*Machine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Machine)
	err := c.cc.Invoke(ctx, MachineService_GetMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) ListMachines(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListMachinesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMachinesResponse)
	err := c.cc.Invoke(ctx, MachineService_ListMachines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) UpdateMachine(ctx context.Context, in *UpdateMachineRequest, opts ...grpc.CallOption) (*Machine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Machine)
	err := c.cc.Invoke(ctx, MachineService_UpdateMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MachineServiceServer is the server API for MachineService service.
// All implementations must embed UnimplementedMachineServiceServer
// for forward compatibility.
type MachineServiceServer interface {
	RegisterMachine(context.Context, *RegisterMachineRequest) (*Machine, error)
	GetMachine(context.Context, *GetMachineRequest) (*Machine, error)
	ListMachines(context.Context, *ListMachinesRequest) (*ListMachinesResponse, error)
	UpdateMachine(context.Context, *UpdateMachineRequest) (*Machine, error)
	mustEmbedUnimplementedMachineServiceServer()
}

// UnimplementedMachineServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMachineServiceServer struct{}

func (UnimplementedMachineServiceServer) RegisterMachine(context.Context, *RegisterMachineRequest) (*Machine, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterMachine not implemented")
}
func (UnimplementedMachineServiceServer) GetMachine(context.Context, *GetMachineRequest) (*Machine, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMachine not implemented")
}
func (UnimplementedMachineServiceServer) ListMachines(context.Context, *ListMachinesRequest) (*ListMachinesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMachines not implemented")
}
func (UnimplementedMachineServiceServer) UpdateMachine(context.Context, *UpdateMachineRequest) (*Machine, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMachine not implemented")
}
func (UnimplementedMachineServiceServer) mustEmbedUnimplementedMachineServiceServer() {}
func (UnimplementedMachineServiceServer) testEmbeddedByValue()                        {}

// UnsafeMachineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MachineServiceServer will
// result in compilation errors.
type UnsafeMachineServiceServer interface {
	mustEmbedUnimplementedMachineServiceServer()
}

func RegisterMachineServiceServer(s grpc.ServiceRegistrar, srv MachineServiceServer) {
	// If the following call panics, it indicates UnimplementedMachineServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MachineService_ServiceDesc, srv)
}

func _MachineService_RegisterMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).RegisterMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_RegisterMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).RegisterMachine(ctx, req.(*RegisterMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_GetMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).GetMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_GetMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).GetMachine(ctx, req.(*GetMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_ListMachines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMachinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).ListMachines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_ListMachines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).ListMachines(ctx, req.(*ListMachinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_UpdateMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).UpdateMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_UpdateMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).UpdateMachine(ctx, req.(*UpdateMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MachineService_ServiceDesc is the grpc.ServiceDesc for MachineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MachineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "baremetal.v1.MachineService",
	HandlerType: (*MachineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterMachine",
			Handler:    _MachineService_RegisterMachine_Handler,
		},
		{
			MethodName: "GetMachine",
			Handler:    _MachineService_GetMachine_Handler,
		},
		{
			MethodName: "ListMachines",
			Handler:    _MachineService_ListMachines_Handler,
		},
		{
			MethodName: "UpdateMachine",
			Handler:    _MachineService_UpdateMachine_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/baremetal/v1/baremetal.proto",
}

const (
	PlanService_GetPlan_FullMethodName   = "/baremetal.v1.PlanService/GetPlan"
	PlanService_ListPlans_FullMethodName = "/baremetal.v1.PlanService/ListPlans"
)

// PlanServiceClient is the client API for PlanService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlanServiceClient interface {
	GetPlan(ctx context.Context, in *GetPlanRequest, opts ...grpc.CallOption) (*Plan, error)
	ListPlans(ctx context.Context, in *ListPlansRequest, opts ...grpc.CallOption) (*ListPlansResponse, error)
}

type planServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPlanServiceClient(cc grpc.ClientConnInterface) PlanServiceClient {
	return &planServiceClient{cc}
}

func (c *planServiceClient) GetPlan(ctx context.Context, in *GetPlanRequest, opts ...grpc.CallOption) (*Plan, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Plan)
	err := c.cc.Invoke(ctx, PlanService_GetPlan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *planServiceClient) ListPlans(ctx context.Context, in *ListPlansRequest, opts ...grpc.CallOption) (*ListPlansResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPlansResponse)
	err := c.cc.Invoke(ctx, PlanService_ListPlans_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlanServiceServer is the server API for PlanService service.
// All implementations must embed UnimplementedPlanServiceServer
// for forward compatibility.
type PlanServiceServer interface {
	GetPlan(context.Context, *GetPlanRequest) (*Plan, error)
	ListPlans(context.Context, *ListPlansRequest) (*ListPlansResponse, error)
	mustEmbedUnimplementedPlanServiceServer()
}

// UnimplementedPlanServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPlanServiceServer struct{}

func (UnimplementedPlanServiceServer) GetPlan(context.Context, *GetPlanRequest) (*Plan, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPlan not implemented")
}
func (UnimplementedPlanServiceServer) ListPlans(context.Context, *ListPlansRequest) (*ListPlansResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPlans not implemented")
}
func (UnimplementedPlanServiceServer) mustEmbedUnimplementedPlanServiceServer() {}
func (UnimplementedPlanServiceServer) testEmbeddedByValue()                     {}

// UnsafePlanServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlanServiceServer will
// result in compilation errors.
type UnsafePlanServiceServer interface {
	mustEmbedUnimplementedPlanServiceServer()
}

func RegisterPlanServiceServer(s grpc.ServiceRegistrar, srv PlanServiceServer) {
	// If the following call panics, it indicates UnimplementedPlanServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PlanService_ServiceDesc, srv)
}

func _PlanService_GetPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlanServiceServer).GetPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlanService_GetPlan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlanServiceServer).GetPlan(ctx, req.(*GetPlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlanService_ListPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlanServiceServer).ListPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlanService_ListPlans_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlanServiceServer).ListPlans(ctx, req.(*ListPlansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PlanService_ServiceDesc is the grpc.ServiceDesc for PlanService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PlanService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "baremetal.v1.PlanService",
	HandlerType: (*PlanServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPlan",
			Handler:    _PlanService_GetPlan_Handler,
		},
		{
			MethodName: "ListPlans",
			Handler:    _PlanService_ListPlans_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/baremetal/v1/baremetal.proto",
}

const (
	RunService_StartRun_FullMethodName      = "/baremetal.v1.RunService/StartRun"
	RunService_GetRun_FullMethodName        = "/baremetal.v1.RunService/GetRun"
	RunService_ListRuns_FullMethodName      = "/baremetal.v1.RunService/ListRuns"
	RunService_CancelRun_FullMethodName     = "/baremetal.v1.RunService/CancelRun"
	RunService_WatchRuns_FullMethodName     = "/baremetal.v1.RunService/WatchRuns"
	RunService_StreamRunLogs_FullMethodName = "/baremetal.v1.RunService/StreamRunLogs"
)

// RunServiceClient is the client API for RunService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RunServiceClient interface {
	StartRun(ctx context.Context, in *StartRunRequest, opts ...grpc.CallOption) (*Run, error)
	GetRun(ctx context.Context, in *GetRunRequest, opts ...grpc.CallOption) (*Run, error)
	ListRuns(ctx context.Context, in *ListRunsRequest, opts ...grpc.CallOption) (*ListRunsResponse, error)
	CancelRun(ctx context.Context, in *CancelRunRequest, opts ...grpc.CallOption) (*Run, error)
	WatchRuns(ctx context.Context, in *WatchRunsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RunEvent], error)
	StreamRunLogs(ctx context.Context, in *StreamRunLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogChunk], error)
}

type runServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRunServiceClient(cc grpc.ClientConnInterface) RunServiceClient {
	return &runServiceClient{cc}
}

func (c *runServiceClient) StartRun(ctx context.Context, in *StartRunRequest, opts ...grpc.CallOption) (*Run, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Run)
	err := c.cc.Invoke(ctx, RunService_StartRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) GetRun(ctx context.Context, in *GetRunRequest, opts ...grpc.CallOption) (*Run, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Run)
	err := c.cc.Invoke(ctx, RunService_GetRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) ListRuns(ctx context.Context, in *ListRunsRequest, opts ...grpc.CallOption) (*ListRunsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRunsResponse)
	err := c.cc.Invoke(ctx, RunService_ListRuns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) CancelRun(ctx context.Context, in *CancelRunRequest, opts ...grpc.CallOption) (*Run, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Run)
	err := c.cc.Invoke(ctx, RunService_CancelRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) WatchRuns(ctx context.Context, in *WatchRunsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RunEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RunService_ServiceDesc.Streams[0], RunService_WatchRuns_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchRunsRequest, RunEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RunService_WatchRunsClient = grpc.ServerStreamingClient[RunEvent]

func (c *runServiceClient) StreamRunLogs(ctx context.Context, in *StreamRunLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RunService_ServiceDesc.Streams[1], RunService_StreamRunLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamRunLogsRequest, LogChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RunService_StreamRunLogsClient = grpc.ServerStreamingClient[LogChunk]

// RunServiceServer is the server API for RunService service.
// All implementations must embed UnimplementedRunServiceServer
// for forward compatibility.
type RunServiceServer interface {
	StartRun(context.Context, *StartRunRequest) (*Run, error)
	GetRun(context.Context, *GetRunRequest) (*Run, error)
	ListRuns(context.Context, *ListRunsRequest) (*ListRunsResponse, error)
	CancelRun(context.Context, *CancelRunRequest) (*Run, error)
	WatchRuns(*WatchRunsRequest, grpc.ServerStreamingServer[RunEvent]) error
	StreamRunLogs(*StreamRunLogsRequest, grpc.ServerStreamingServer[LogChunk]) error
	mustEmbedUnimplementedRunServiceServer()
}

// UnimplementedRunServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRunServiceServer struct{}

func (UnimplementedRunServiceServer) StartRun(context.Context, *StartRunRequest) (*Run, error) {
	return nil, status.Error(codes.Unimplemented, "method StartRun not implemented")
}
func (UnimplementedRunServiceServer) GetRun(context.Context, *GetRunRequest) (*Run, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRun not implemented")
}
func (UnimplementedRunServiceServer) ListRuns(context.Context, *ListRunsRequest) (*ListRunsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRuns not implemented")
}
func (UnimplementedRunServiceServer) CancelRun(context.Context, *CancelRunRequest) (*Run, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelRun not implemented")
}
func (UnimplementedRunServiceServer) WatchRuns(*WatchRunsRequest, grpc.ServerStreamingServer[RunEvent]) error {
	return status.Error(codes.Unimplemented, "method WatchRuns not implemented")
}
func (UnimplementedRunServiceServer) StreamRunLogs(*StreamRunLogsRequest, grpc.ServerStreamingServer[LogChunk]) error {
	return status.Error(codes.Unimplemented, "method StreamRunLogs not implemented")
}
func (UnimplementedRunServiceServer) mustEmbedUnimplementedRunServiceServer() {}
func (UnimplementedRunServiceServer) testEmbeddedByValue()                    {}

// UnsafeRunServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RunServiceServer will
// result in compilation errors.
type UnsafeRunServiceServer interface {
	mustEmbedUnimplementedRunServiceServer()
}

func RegisterRunServiceServer(s grpc.ServiceRegistrar, srv RunServiceServer) {
	// If the following call panics, it indicates UnimplementedRunServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RunService_ServiceDesc, srv)
}

func _RunService_StartRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).StartRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_StartRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).StartRun(ctx, req.(*StartRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_GetRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).GetRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_GetRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).GetRun(ctx, req.(*GetRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_ListRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).ListRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_ListRuns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).ListRuns(ctx, req.(*ListRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_CancelRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).CancelRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_CancelRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).CancelRun(ctx, req.(*CancelRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_WatchRuns_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRunsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RunServiceServer).WatchRuns(m, &grpc.GenericServerStream[WatchRunsRequest, RunEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RunService_WatchRunsServer = grpc.ServerStreamingServer[RunEvent]

func _RunService_StreamRunLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRunLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RunServiceServer).StreamRunLogs(m, &grpc.GenericServerStream[StreamRunLogsRequest, LogChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RunService_StreamRunLogsServer = grpc.ServerStreamingServer[LogChunk]

// RunService_ServiceDesc is the grpc.ServiceDesc for RunService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RunService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "baremetal.v1.RunService",
	HandlerType: (*RunServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartRun",
			Handler:    _RunService_StartRun_Handler,
		},
		{
			MethodName: "GetRun",
			Handler:    _RunService_GetRun_Handler,
		},
		{
			MethodName: "ListRuns",
			Handler:    _RunService_ListRuns_Handler,
		},
		{
			MethodName: "CancelRun",
			Handler:    _RunService_CancelRun_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchRuns",
			Handler:       _RunService_WatchRuns_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamRunLogs",
			Handler:       _RunService_StreamRunLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/baremetal/v1/baremetal.proto",
}
