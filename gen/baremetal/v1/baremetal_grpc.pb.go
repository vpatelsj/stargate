// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: baremetal/v1/baremetal.proto

package baremetalv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MachineService_RegisterMachine_FullMethodName  = "/baremetal.v1.MachineService/RegisterMachine"
	MachineService_GetMachine_FullMethodName       = "/baremetal.v1.MachineService/GetMachine"
	MachineService_ListMachines_FullMethodName     = "/baremetal.v1.MachineService/ListMachines"
	MachineService_UpdateMachine_FullMethodName    = "/baremetal.v1.MachineService/UpdateMachine"
	MachineService_RebootMachine_FullMethodName    = "/baremetal.v1.MachineService/RebootMachine"
	MachineService_ReimageMachine_FullMethodName   = "/baremetal.v1.MachineService/ReimageMachine"
	MachineService_EnterMaintenance_FullMethodName = "/baremetal.v1.MachineService/EnterMaintenance"
	MachineService_ExitMaintenance_FullMethodName  = "/baremetal.v1.MachineService/ExitMaintenance"
	MachineService_CancelOperation_FullMethodName  = "/baremetal.v1.MachineService/CancelOperation"
)

// MachineServiceClient is the client API for MachineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MachineService provides high-level operations on baremetal machines.
// Customers use this to manage machine lifecycle: reboot, reimage, enter/exit maintenance.
type MachineServiceClient interface {
	RegisterMachine(ctx context.Context, in *RegisterMachineRequest, opts ...grpc.CallOption) (*Machine, error)
	GetMachine(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*Machine, error)
	ListMachines(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListMachinesResponse, error)
	UpdateMachine(ctx context.Context, in *UpdateMachineRequest, opts ...grpc.CallOption) (*Machine, error)
	// Lifecycle operations - each returns an Operation for tracking
	RebootMachine(ctx context.Context, in *RebootMachineRequest, opts ...grpc.CallOption) (*Operation, error)
	ReimageMachine(ctx context.Context, in *ReimageMachineRequest, opts ...grpc.CallOption) (*Operation, error)
	EnterMaintenance(ctx context.Context, in *EnterMaintenanceRequest, opts ...grpc.CallOption) (*Operation, error)
	ExitMaintenance(ctx context.Context, in *ExitMaintenanceRequest, opts ...grpc.CallOption) (*Operation, error)
	CancelOperation(ctx context.Context, in *CancelOperationRequest, opts ...grpc.CallOption) (*Operation, error)
}

type machineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMachineServiceClient(cc grpc.ClientConnInterface) MachineServiceClient {
	return &machineServiceClient{cc}
}

func (c *machineServiceClient) RegisterMachine(ctx context.Context, in *RegisterMachineRequest, opts ...grpc.CallOption) (*Machine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Machine)
	err := c.cc.Invoke(ctx, MachineService_RegisterMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) GetMachine(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*Machine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Machine)
	err := c.cc.Invoke(ctx, MachineService_GetMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) ListMachines(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListMachinesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMachinesResponse)
	err := c.cc.Invoke(ctx, MachineService_ListMachines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) UpdateMachine(ctx context.Context, in *UpdateMachineRequest, opts ...grpc.CallOption) (*Machine, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Machine)
	err := c.cc.Invoke(ctx, MachineService_UpdateMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) RebootMachine(ctx context.Context, in *RebootMachineRequest, opts ...grpc.CallOption) (*Operation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Operation)
	err := c.cc.Invoke(ctx, MachineService_RebootMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) ReimageMachine(ctx context.Context, in *ReimageMachineRequest, opts ...grpc.CallOption) (*Operation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Operation)
	err := c.cc.Invoke(ctx, MachineService_ReimageMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) EnterMaintenance(ctx context.Context, in *EnterMaintenanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Operation)
	err := c.cc.Invoke(ctx, MachineService_EnterMaintenance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) ExitMaintenance(ctx context.Context, in *ExitMaintenanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Operation)
	err := c.cc.Invoke(ctx, MachineService_ExitMaintenance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) CancelOperation(ctx context.Context, in *CancelOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Operation)
	err := c.cc.Invoke(ctx, MachineService_CancelOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MachineServiceServer is the server API for MachineService service.
// All implementations must embed UnimplementedMachineServiceServer
// for forward compatibility.
//
// MachineService provides high-level operations on baremetal machines.
// Customers use this to manage machine lifecycle: reboot, reimage, enter/exit maintenance.
type MachineServiceServer interface {
	RegisterMachine(context.Context, *RegisterMachineRequest) (*Machine, error)
	GetMachine(context.Context, *GetMachineRequest) (*Machine, error)
	ListMachines(context.Context, *ListMachinesRequest) (*ListMachinesResponse, error)
	UpdateMachine(context.Context, *UpdateMachineRequest) (*Machine, error)
	// Lifecycle operations - each returns an Operation for tracking
	RebootMachine(context.Context, *RebootMachineRequest) (*Operation, error)
	ReimageMachine(context.Context, *ReimageMachineRequest) (*Operation, error)
	EnterMaintenance(context.Context, *EnterMaintenanceRequest) (*Operation, error)
	ExitMaintenance(context.Context, *ExitMaintenanceRequest) (*Operation, error)
	CancelOperation(context.Context, *CancelOperationRequest) (*Operation, error)
	mustEmbedUnimplementedMachineServiceServer()
}

// UnimplementedMachineServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMachineServiceServer struct{}

func (UnimplementedMachineServiceServer) RegisterMachine(context.Context, *RegisterMachineRequest) (*Machine, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterMachine not implemented")
}
func (UnimplementedMachineServiceServer) GetMachine(context.Context, *GetMachineRequest) (*Machine, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMachine not implemented")
}
func (UnimplementedMachineServiceServer) ListMachines(context.Context, *ListMachinesRequest) (*ListMachinesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMachines not implemented")
}
func (UnimplementedMachineServiceServer) UpdateMachine(context.Context, *UpdateMachineRequest) (*Machine, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMachine not implemented")
}
func (UnimplementedMachineServiceServer) RebootMachine(context.Context, *RebootMachineRequest) (*Operation, error) {
	return nil, status.Error(codes.Unimplemented, "method RebootMachine not implemented")
}
func (UnimplementedMachineServiceServer) ReimageMachine(context.Context, *ReimageMachineRequest) (*Operation, error) {
	return nil, status.Error(codes.Unimplemented, "method ReimageMachine not implemented")
}
func (UnimplementedMachineServiceServer) EnterMaintenance(context.Context, *EnterMaintenanceRequest) (*Operation, error) {
	return nil, status.Error(codes.Unimplemented, "method EnterMaintenance not implemented")
}
func (UnimplementedMachineServiceServer) ExitMaintenance(context.Context, *ExitMaintenanceRequest) (*Operation, error) {
	return nil, status.Error(codes.Unimplemented, "method ExitMaintenance not implemented")
}
func (UnimplementedMachineServiceServer) CancelOperation(context.Context, *CancelOperationRequest) (*Operation, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelOperation not implemented")
}
func (UnimplementedMachineServiceServer) mustEmbedUnimplementedMachineServiceServer() {}
func (UnimplementedMachineServiceServer) testEmbeddedByValue()                        {}

// UnsafeMachineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MachineServiceServer will
// result in compilation errors.
type UnsafeMachineServiceServer interface {
	mustEmbedUnimplementedMachineServiceServer()
}

func RegisterMachineServiceServer(s grpc.ServiceRegistrar, srv MachineServiceServer) {
	// If the following call panics, it indicates UnimplementedMachineServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MachineService_ServiceDesc, srv)
}

func _MachineService_RegisterMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).RegisterMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_RegisterMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).RegisterMachine(ctx, req.(*RegisterMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_GetMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).GetMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_GetMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).GetMachine(ctx, req.(*GetMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_ListMachines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMachinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).ListMachines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_ListMachines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).ListMachines(ctx, req.(*ListMachinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_UpdateMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).UpdateMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_UpdateMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).UpdateMachine(ctx, req.(*UpdateMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_RebootMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebootMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).RebootMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_RebootMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).RebootMachine(ctx, req.(*RebootMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_ReimageMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReimageMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).ReimageMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_ReimageMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).ReimageMachine(ctx, req.(*ReimageMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_EnterMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnterMaintenanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).EnterMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_EnterMaintenance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).EnterMaintenance(ctx, req.(*EnterMaintenanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_ExitMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExitMaintenanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).ExitMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_ExitMaintenance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).ExitMaintenance(ctx, req.(*ExitMaintenanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_CancelOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).CancelOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineService_CancelOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).CancelOperation(ctx, req.(*CancelOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MachineService_ServiceDesc is the grpc.ServiceDesc for MachineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MachineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "baremetal.v1.MachineService",
	HandlerType: (*MachineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterMachine",
			Handler:    _MachineService_RegisterMachine_Handler,
		},
		{
			MethodName: "GetMachine",
			Handler:    _MachineService_GetMachine_Handler,
		},
		{
			MethodName: "ListMachines",
			Handler:    _MachineService_ListMachines_Handler,
		},
		{
			MethodName: "UpdateMachine",
			Handler:    _MachineService_UpdateMachine_Handler,
		},
		{
			MethodName: "RebootMachine",
			Handler:    _MachineService_RebootMachine_Handler,
		},
		{
			MethodName: "ReimageMachine",
			Handler:    _MachineService_ReimageMachine_Handler,
		},
		{
			MethodName: "EnterMaintenance",
			Handler:    _MachineService_EnterMaintenance_Handler,
		},
		{
			MethodName: "ExitMaintenance",
			Handler:    _MachineService_ExitMaintenance_Handler,
		},
		{
			MethodName: "CancelOperation",
			Handler:    _MachineService_CancelOperation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "baremetal/v1/baremetal.proto",
}

const (
	OperationService_GetOperation_FullMethodName        = "/baremetal.v1.OperationService/GetOperation"
	OperationService_ListOperations_FullMethodName      = "/baremetal.v1.OperationService/ListOperations"
	OperationService_WatchOperations_FullMethodName     = "/baremetal.v1.OperationService/WatchOperations"
	OperationService_StreamOperationLogs_FullMethodName = "/baremetal.v1.OperationService/StreamOperationLogs"
)

// OperationServiceClient is the client API for OperationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// OperationService provides read-only access to operations and streaming.
// Customers track operation progress via Get/List/Watch/StreamLogs.
type OperationServiceClient interface {
	GetOperation(ctx context.Context, in *GetOperationRequest, opts ...grpc.CallOption) (*Operation, error)
	ListOperations(ctx context.Context, in *ListOperationsRequest, opts ...grpc.CallOption) (*ListOperationsResponse, error)
	WatchOperations(ctx context.Context, in *WatchOperationsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OperationEvent], error)
	StreamOperationLogs(ctx context.Context, in *StreamOperationLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogChunk], error)
}

type operationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOperationServiceClient(cc grpc.ClientConnInterface) OperationServiceClient {
	return &operationServiceClient{cc}
}

func (c *operationServiceClient) GetOperation(ctx context.Context, in *GetOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Operation)
	err := c.cc.Invoke(ctx, OperationService_GetOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) ListOperations(ctx context.Context, in *ListOperationsRequest, opts ...grpc.CallOption) (*ListOperationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOperationsResponse)
	err := c.cc.Invoke(ctx, OperationService_ListOperations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) WatchOperations(ctx context.Context, in *WatchOperationsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OperationEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &OperationService_ServiceDesc.Streams[0], OperationService_WatchOperations_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchOperationsRequest, OperationEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OperationService_WatchOperationsClient = grpc.ServerStreamingClient[OperationEvent]

func (c *operationServiceClient) StreamOperationLogs(ctx context.Context, in *StreamOperationLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &OperationService_ServiceDesc.Streams[1], OperationService_StreamOperationLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamOperationLogsRequest, LogChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OperationService_StreamOperationLogsClient = grpc.ServerStreamingClient[LogChunk]

// OperationServiceServer is the server API for OperationService service.
// All implementations must embed UnimplementedOperationServiceServer
// for forward compatibility.
//
// OperationService provides read-only access to operations and streaming.
// Customers track operation progress via Get/List/Watch/StreamLogs.
type OperationServiceServer interface {
	GetOperation(context.Context, *GetOperationRequest) (*Operation, error)
	ListOperations(context.Context, *ListOperationsRequest) (*ListOperationsResponse, error)
	WatchOperations(*WatchOperationsRequest, grpc.ServerStreamingServer[OperationEvent]) error
	StreamOperationLogs(*StreamOperationLogsRequest, grpc.ServerStreamingServer[LogChunk]) error
	mustEmbedUnimplementedOperationServiceServer()
}

// UnimplementedOperationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOperationServiceServer struct{}

func (UnimplementedOperationServiceServer) GetOperation(context.Context, *GetOperationRequest) (*Operation, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOperation not implemented")
}
func (UnimplementedOperationServiceServer) ListOperations(context.Context, *ListOperationsRequest) (*ListOperationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListOperations not implemented")
}
func (UnimplementedOperationServiceServer) WatchOperations(*WatchOperationsRequest, grpc.ServerStreamingServer[OperationEvent]) error {
	return status.Error(codes.Unimplemented, "method WatchOperations not implemented")
}
func (UnimplementedOperationServiceServer) StreamOperationLogs(*StreamOperationLogsRequest, grpc.ServerStreamingServer[LogChunk]) error {
	return status.Error(codes.Unimplemented, "method StreamOperationLogs not implemented")
}
func (UnimplementedOperationServiceServer) mustEmbedUnimplementedOperationServiceServer() {}
func (UnimplementedOperationServiceServer) testEmbeddedByValue()                          {}

// UnsafeOperationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OperationServiceServer will
// result in compilation errors.
type UnsafeOperationServiceServer interface {
	mustEmbedUnimplementedOperationServiceServer()
}

func RegisterOperationServiceServer(s grpc.ServiceRegistrar, srv OperationServiceServer) {
	// If the following call panics, it indicates UnimplementedOperationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OperationService_ServiceDesc, srv)
}

func _OperationService_GetOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).GetOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperationService_GetOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).GetOperation(ctx, req.(*GetOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_ListOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).ListOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperationService_ListOperations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).ListOperations(ctx, req.(*ListOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_WatchOperations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchOperationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OperationServiceServer).WatchOperations(m, &grpc.GenericServerStream[WatchOperationsRequest, OperationEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OperationService_WatchOperationsServer = grpc.ServerStreamingServer[OperationEvent]

func _OperationService_StreamOperationLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamOperationLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OperationServiceServer).StreamOperationLogs(m, &grpc.GenericServerStream[StreamOperationLogsRequest, LogChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OperationService_StreamOperationLogsServer = grpc.ServerStreamingServer[LogChunk]

// OperationService_ServiceDesc is the grpc.ServiceDesc for OperationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OperationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "baremetal.v1.OperationService",
	HandlerType: (*OperationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOperation",
			Handler:    _OperationService_GetOperation_Handler,
		},
		{
			MethodName: "ListOperations",
			Handler:    _OperationService_ListOperations_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchOperations",
			Handler:       _OperationService_WatchOperations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamOperationLogs",
			Handler:       _OperationService_StreamOperationLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "baremetal/v1/baremetal.proto",
}
